<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Two-Board Galton + Bandit Strategies</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f4f4f4;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 10px;
    }
    #controls {
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
    }
    label {
      font-size: 13px;
      background: #ffffff;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    canvas {
      background: #ffffff;
      border: 1px solid #ccc;
    }
    #info {
      margin-top: 6px;
      font-size: 13px;
      background: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      max-width: 900px;
    }
  </style>
</head>
<body>
<h3>两板高尔顿板 + Bandit 策略（含 strategic / worse-strategic）</h3>

<div id="controls">
  <label>
    层数：
    <input id="levels" type="range" min="3" max="18" value="12">
    <span id="levelsVal">12</span>
  </label>

  <label>
    板 A 的 p<sub>A</sub>（蓝）：
    <input id="pRightA" type="range" min="0" max="1" step="0.01" value="0.80">
    <span id="pAVal">0.80</span>
  </label>

  <label>
    板 B 的 p<sub>B</sub>（橙）：
    <input id="pRightB" type="range" min="0" max="1" step="0.01" value="0.20">
    <span id="pBVal">0.20</span>
  </label>

  <label>
    策略：
    <select id="strategy">
      <option value="random">random：随机 A/B</option>
      <option value="alternate">alternate：交替 A,B</option>
      <option value="only_high">only_high：只选 A</option>
      <option value="only_low">only_low：只选 B</option>
      <option value="two_to_one">two_to_one：A:B=2:1</option>
      <option value="strategic" selected>strategic：θ_{n,c}</option>
      <option value="worse_strategic">worse-strategic：反向 θ_{n,c}</option>
    </select>
  </label>

  <label>
    θ<sub>n,c</sub> 的 c：
    <input id="cParam" type="range" min="-2" max="2" step="0.05" value="0">
    <span id="cVal">0.00</span>
  </label>

  <label>
    θ<sub>n,c</sub> 的 n：
    <input id="nTheta" type="range" min="20" max="12000" step="100" value="6000">
    <span id="nThetaVal">6000</span>
  </label>

  <label>
    速度：
    <input id="speed" type="range" min="0.2" max="3" step="0.1" value="1">
    <span id="speedVal">1.0x</span>
  </label>

  <button id="resetBtn">重置</button>
</div>

<canvas id="canvas" width="900" height="760"></canvas>

<div id="info">
  <span id="infoText"></span>
</div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // ===== 控件 =====
  const levelsSlider = document.getElementById('levels');
  const levelsVal = document.getElementById('levelsVal');

  const pRightASlider = document.getElementById('pRightA');
  const pAVal = document.getElementById('pAVal');

  const pRightBSlider = document.getElementById('pRightB');
  const pBVal = document.getElementById('pBVal');

  const strategySelect = document.getElementById('strategy');

  const cSlider = document.getElementById('cParam');
  const cVal = document.getElementById('cVal');

  const nThetaSlider = document.getElementById('nTheta');
  const nThetaVal = document.getElementById('nThetaVal');

  const speedSlider = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');

  const resetBtn = document.getElementById('resetBtn');
  const infoText = document.getElementById('infoText');

  // 初始参数
  let levels = parseInt(levelsSlider.value, 10);
  let pRightA = parseFloat(pRightASlider.value);
  let pRightB = parseFloat(pRightBSlider.value);
  let strategy = strategySelect.value;
  let cParam = parseFloat(cSlider.value);
  let nTheta = parseInt(nThetaSlider.value, 10);
  let speedFactor = parseFloat(speedSlider.value);

  levelsVal.textContent = levels;
  pAVal.textContent = pRightA.toFixed(2);
  pBVal.textContent = pRightB.toFixed(2);
  cVal.textContent = cParam.toFixed(2);
  nThetaVal.textContent = nTheta.toString();
  speedVal.textContent = speedFactor.toFixed(1) + 'x';

  levelsSlider.addEventListener('input', () => {
    levels = parseInt(levelsSlider.value, 10);
    levelsVal.textContent = levels;
    resetAll();
  });

  pRightASlider.addEventListener('input', () => {
    pRightA = parseFloat(pRightASlider.value);
    pAVal.textContent = pRightA.toFixed(2);
    recomputeArms();
  });

  pRightBSlider.addEventListener('input', () => {
    pRightB = parseFloat(pRightBSlider.value);
    pBVal.textContent = pRightB.toFixed(2);
    recomputeArms();
  });

  strategySelect.addEventListener('change', () => {
    strategy = strategySelect.value;
  });

  cSlider.addEventListener('input', () => {
    cParam = parseFloat(cSlider.value);
    cVal.textContent = cParam.toFixed(2);
    recomputeArms();
  });

  nThetaSlider.addEventListener('input', () => {
    nTheta = parseInt(nThetaSlider.value, 10);
    nThetaVal.textContent = nTheta.toString();
    recomputeArms();
  });

  speedSlider.addEventListener('input', () => {
    speedFactor = parseFloat(speedSlider.value);
    speedVal.textContent = speedFactor.toFixed(1) + 'x';
  });

  resetBtn.addEventListener('click', () => {
    resetAll();
  });

  // ===== 布局参数 =====
  const W = canvas.width;
  const H = canvas.height;

  const boardBottomY = H * 0.55;          // 上方板区域底部
  const topMargin = 36;

  const histTop = H * 0.58;               // 主直方图区域（绝对计数）
  const histHeight = H * 0.17;
  const insetGap = H * 0.02;
  const insetTop = histTop + histHeight + insetGap; // 放大+正态对比区域
  const insetHeight = H * 0.17;

  const pegRadius = 3;
  const ballRadius = 4;
  const maxTrailLength = 48; // 显示小球轨迹长度

  const spanY = boardBottomY - topMargin;
  const preferredStepXScale = 1.08; // x 间距与 y 间距的比例，让三角网格更均匀

  const baseBallSpeed = 0.022;
  const baseBallsPerSec = 15;

  const histTargetBalls = 3200; // 约达到这数量时柱子接近满高

  let balls = [];
  let lastTime = null;
  let emitAccumulator = 0;
  let ballCount = 0;
  let pegDecisionCount = 0; // 记录每次撞钉子的决策序号
  let finishedBalls = 0;

  function getRowGeometry(rowIndex) {
    const cappedRow = Math.max(0, Math.min(levels, rowIndex));
    const rowCols = cappedRow + 1;
    const stepY = spanY / (levels + 1);
    const idealStepX = Math.min(W * 0.9 / Math.max(levels, 1), stepY * preferredStepXScale);
    const rowSpan = idealStepX * (rowCols - 1);
    const leftX = (W - rowSpan) / 2;
    const stepX = rowCols > 1 ? idealStepX : 0;
    return { leftX, rowSpan, stepX, rowCols };
  }

  function projectBall(row, xNorm, yProgress) {
    const stepY = spanY / (levels + 1);
    const y = topMargin + yProgress * stepY + (row + 1) * stepY;

    const rowUsed = Math.max(row, 0);
    const geom = getRowGeometry(rowUsed);
    const colIndex = (xNorm + rowUsed) / 2;
    const x = geom.rowCols === 1
      ? W / 2
      : geom.leftX + colIndex * geom.stepX;
    return { x, y };
  }

  // 直方图 bins（混合）
  let bins = [];
  function resetBins() {
    bins = new Array(levels + 1).fill(0);
  }

  function xNormToBinIndex(xNorm) {
    return (xNorm + levels) / 2; // xNorm ∈ {-levels,-levels+2,...,levels}
  }

  // 板使用次数（按每次撞钉子计数）
  let boardCounts = [0, 0]; // [A, B]

  // ===== strategic / worse-strategic 离线臂序列 =====
  let strategicArms = [];       // 0/1 长度 nTheta
  let worseStrategicArms = [];  // 0/1 长度 nTheta

  function muA() {
    return 2 * pRightA - 1;
  }
  function muB() {
    return 2 * pRightB - 1;
  }

  function randn(mu, sigma) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mu + sigma * z0;
  }

  function computeArms(n, c, muL, muR, sigma, reverse=false) {
    const W_L = new Array(n);
    const W_R = new Array(n);
    for (let i = 0; i < n; i++) {
      W_L[i] = randn(muL, sigma);
      W_R[i] = randn(muR, sigma);
    }

    const arms = new Array(n); // 0=A, 1=B
    const T_path = new Array(n + 1);
    T_path[0] = 0;

    let sumZ = 0;
    let sumCentered = 0;

    // 第 1 步
    arms[0] = Math.random() < 0.5 ? 0 : 1; // 0=L(A),1=R(B)
    let z, mu_theta;

    if (arms[0] === 0) {
      z = W_L[0];
      mu_theta = muL;
    } else {
      z = W_R[0];
      mu_theta = muR;
    }
    sumZ += z;
    sumCentered += (z - mu_theta) / sigma;
    T_path[1] = (sumZ / n) + (sumCentered / Math.sqrt(n));

    // 第 2...n 步
    for (let m = 2; m <= n; m++) {
      const T_prev = T_path[m - 1]; // 对应 R 的 T_{m-1,n}
      const weight = 1.0 - (m - 1) / n;
      const thr = c - weight * (muL + muR) / 2.0;

      let arm;
      if (!reverse) {
        // strategic
        arm = (T_prev <= thr) ? 0 : 1;
      } else {
        // worse-strategic：反着选
        arm = (T_prev <= thr) ? 1 : 0;
      }
      arms[m - 1] = arm;

      if (arm === 0) {
        z = W_L[m - 1];
        mu_theta = muL;
      } else {
        z = W_R[m - 1];
        mu_theta = muR;
      }
      sumZ += z;
      sumCentered += (z - mu_theta) / sigma;
      T_path[m] = (sumZ / n) + (sumCentered / Math.sqrt(n));
    }

    return arms;
  }

  function recomputeArms() {
    const n = nTheta;
    const muL = muA();
    const muR = muB();
    const sigma = 1.0;

    strategicArms = computeArms(n, cParam, muL, muR, sigma, false);
    worseStrategicArms = computeArms(n, cParam, muL, muR, sigma, true);
  }

  // 初始算一次
  recomputeArms();

  // ===== Ball 类 =====
  class Ball {
    constructor() {
      this.row = -1;
      this.xNorm = 0;
      this.yProgress = 0;
      this.done = false;
      this.lastBoard = 0;  // 最近一次撞钉子的板，用于着色
      this.trail = [projectBall(this.row, this.xNorm, this.yProgress)];
    }

    step(dt, ballSpeed) {
      if (this.done) return;

      this.yProgress += ballSpeed * dt;
      const stepY = spanY / (levels + 1);

      if (this.yProgress >= 1) {
        this.yProgress = 0;
        this.row += 1;

        if (this.row === 0) {
          // 刚进入第一层前，不动 xNorm
        } else if (this.row <= levels) {
          const board = chooseBoardWithStrategy(pegDecisionCount);
          const pRight = (board === 0 ? pRightA : pRightB);
          this.lastBoard = board;

          const r = Math.random();
          if (r < pRight) this.xNorm += 1;
          else this.xNorm -= 1;

          boardCounts[board] += 1;
          pegDecisionCount += 1;
        }

        if (this.row >= levels) {
          this.done = true;

          finishedBalls += 1;

          // 落地 -> 更新直方图
          const finalX = this.xNorm;
          const idx = xNormToBinIndex(finalX);
          if (idx >= 0 && idx < bins.length) {
            bins[Math.round(idx)] += 1;
          }
        }
      }

      const pos = projectBall(this.row, this.xNorm, this.yProgress);
      this.trail.push(pos);
      if (this.trail.length > maxTrailLength) {
        this.trail.shift();
      }
    }

    draw(ctx) {
      if (this.done) return;

      const { x, y } = projectBall(this.row, this.xNorm, this.yProgress);
      const colorBase = (this.lastBoard === 0)
        ? "0, 120, 255"
        : "255, 140, 0";

      ctx.save();
      ctx.lineWidth = 1.6;
      for (let i = 1; i < this.trail.length; i++) {
        const prev = this.trail[i - 1];
        const curr = this.trail[i];
        const t = i / this.trail.length;
        const alpha = 0.12 + 0.55 * t;
        ctx.strokeStyle = `rgba(${colorBase}, ${alpha})`;
        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.lineTo(curr.x, curr.y);
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${colorBase}, 0.9)`;
      ctx.fill();
      ctx.restore();
    }
  }

  // ===== 策略选板 =====
  function chooseBoardBasic(ballIndex, strategyName) {
    if (strategyName === 'random') {
      return Math.random() < 0.5 ? 0 : 1;
    } else if (strategyName === 'alternate') {
      return ballIndex % 2; // 0,1,0,1,...
    } else if (strategyName === 'only_high') {
      return 0;
    } else if (strategyName === 'only_low') {
      return 1;
    } else if (strategyName === 'two_to_one') {
      return Math.random() < (2/3) ? 0 : 1;
    } else {
      return Math.random() < 0.5 ? 0 : 1;
    }
  }

  function chooseBoardWithStrategy(trialIndex = pegDecisionCount) {
    if (strategy === 'strategic') {
      if (trialIndex < nTheta) {
        return strategicArms[trialIndex];  // 0/1
      } else {
        // 超过 n 后，退回 random
        return chooseBoardBasic(trialIndex, 'random');
      }
    } else if (strategy === 'worse_strategic') {
      if (trialIndex < nTheta) {
        return worseStrategicArms[trialIndex];
      } else {
        return chooseBoardBasic(trialIndex, 'random');
      }
    } else {
      return chooseBoardBasic(trialIndex, strategy);
    }
  }

  // ===== 发球 =====
  function emitBalls(dt, ballsPerSec) {
    emitAccumulator += dt;
    const interval = 1000 / ballsPerSec;

    while (emitAccumulator > interval) {
      emitAccumulator -= interval;
      balls.push(new Ball());
      ballCount += 1;
    }

    if (balls.length > 400) {
      balls = balls.filter(b => !b.done);
    }
  }

  // ===== 绘图 =====
  function drawPegs() {
    ctx.fillStyle = "#444";
    const spanY = boardBottomY - topMargin;
    const stepY = spanY / (levels + 1);

    for (let r = 0; r < levels; r++) {
      const { leftX, stepX, rowCols } = getRowGeometry(r);
      const y = topMargin + (r + 1) * stepY;
      for (let c = 0; c < rowCols; c++) {
        const x = rowCols === 1 ? W / 2 : leftX + c * stepX;
        ctx.beginPath();
        ctx.arc(x, y, pegRadius, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  const sqrtTwoPi = Math.sqrt(2 * Math.PI);
  function gaussian(x, mean, std) {
    return Math.exp(-0.5 * Math.pow((x - mean) / std, 2)) / (std * sqrtTwoPi);
  }

  function computeStats() {
    const total = bins.reduce((a, b) => a + b, 0);
    if (total === 0) {
      return { total: 0, mean: 0, std: 1 };
    }

    const positions = bins.map((_, i) => (i * 2 - levels));
    const mean = positions.reduce((acc, x, i) => acc + x * bins[i], 0) / total;
    const variance = positions.reduce((acc, x, i) => {
      const d = x - mean;
      return acc + d * d * bins[i];
    }, 0) / total;
    const std = Math.max(Math.sqrt(Math.max(variance, 1e-6)), 1e-3);
    return { total, mean, std };
  }

  function drawHistogram(stats) {
    const spanX = W * 0.72;
    const leftX = (W - spanX) / 2;
    const barWidth = spanX / bins.length;
    const maxBin = Math.max(...bins, 1);
    const scaledTarget = Math.max(140, Math.min(histTargetBalls, maxBin * 3.2));
    const pixelsPerBall = histHeight / scaledTarget;

    ctx.fillStyle = "#f8f8f8";
    ctx.fillRect(leftX - 8, histTop - 6, spanX + 16, histHeight + 12);

    // 背景热度层：按当前相对频率先上色，这样少量球也能看出形状
    for (let i = 0; i < bins.length; i++) {
      const x = leftX + i * barWidth;
      const rel = bins[i] / maxBin;
      const alpha = 0.12 + 0.48 * rel;
      ctx.fillStyle = `rgba(80, 160, 255, ${alpha})`;
      ctx.fillRect(x, histTop, barWidth * 0.8, histHeight);
    }

    // 灰色条形（绝对计数，随最大值自适应缩放）
    for (let i = 0; i < bins.length; i++) {
      const h = Math.min(histHeight, bins[i] * pixelsPerBall);
      const x = leftX + i * barWidth;
      const y = histTop + histHeight - h;
      ctx.fillStyle = "#bbbbbb";
      ctx.fillRect(x, y, barWidth * 0.8, h);
    }

    // 顶部轮廓线（让形状更明显）
    ctx.strokeStyle = "#444444";
    ctx.beginPath();
    let first = true;
    for (let i = 0; i < bins.length; i++) {
      const h = Math.min(histHeight, bins[i] * pixelsPerBall);
      const xCenter = leftX + i * barWidth + barWidth * 0.4;
      const yTop = histTop + histHeight - h;
      if (first) {
        ctx.moveTo(xCenter, yTop);
        first = false;
      } else {
        ctx.lineTo(xCenter, yTop);
      }
    }
    ctx.stroke();

    ctx.fillStyle = "#555";
    ctx.font = "12px sans-serif";
    ctx.fillText("主直方图：绝对计数（灰）+ 热度层（蓝）", leftX, histTop - 10);

    // x轴
    ctx.strokeStyle = "#000";
    ctx.beginPath();
    ctx.moveTo(leftX, histTop + histHeight);
    ctx.lineTo(leftX + spanX, histTop + histHeight);
    ctx.stroke();
  }

  function drawDetailInset(stats) {
    const spanX = W * 0.72;
    const leftX = (W - spanX) / 2;
    const barWidth = spanX / bins.length;

    const total = stats.total;
    const freq = bins.map(v => total > 0 ? v / total : 0);
    const freqMax = total > 0 ? Math.max(...freq, 1e-6) : 1;

    let normalPeak = 0;
    if (total > 0 && stats.std > 1e-6) {
      normalPeak = gaussian(stats.mean, stats.mean, stats.std) * 2; // 乘以 bin 宽度（2）
    }

    const pixelsPerProb = insetHeight / Math.max(freqMax, normalPeak || 0.0001);

    ctx.fillStyle = "#f6f8ff";
    ctx.fillRect(leftX - 8, insetTop - 8, spanX + 16, insetHeight + 16);

    // 相对频率条形
    ctx.fillStyle = "rgba(120, 120, 120, 0.85)";
    for (let i = 0; i < bins.length; i++) {
      const h = freq[i] * pixelsPerProb;
      const x = leftX + i * barWidth;
      const y = insetTop + insetHeight - h;
      ctx.fillRect(x, y, barWidth * 0.8, h);
    }

    // 正态拟合线（橙）
    if (total > 0 && stats.std > 1e-6) {
      const steps = 240;
      ctx.strokeStyle = "#ff7f0e";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let s = 0; s <= steps; s++) {
        const xNorm = -levels + (2 * s / steps) * levels;
        const prob = gaussian(xNorm, stats.mean, stats.std) * 2; // 近似每个 bin 的概率质量
        const x = leftX + (s / steps) * spanX;
        const y = insetTop + insetHeight - prob * pixelsPerProb;
        if (s === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    ctx.fillStyle = "#555";
    ctx.font = "12px sans-serif";
    ctx.fillText("放大：相对频率（灰）+ 拟合正态曲线（橙）", leftX, insetTop - 10);

    // x轴
    ctx.strokeStyle = "#000";
    ctx.beginPath();
    ctx.moveTo(leftX, insetTop + insetHeight);
    ctx.lineTo(leftX + spanX, insetTop + insetHeight);
    ctx.stroke();
  }

  function drawBackground() {
    ctx.clearRect(0, 0, W, H);
    // 分割线
    ctx.strokeStyle = "#dddddd";
    ctx.beginPath();
    ctx.moveTo(0, boardBottomY);
    ctx.lineTo(W, boardBottomY);
    ctx.stroke();

    ctx.fillStyle = "#000";
    ctx.font = "14px sans-serif";
    ctx.fillText("上：两板高尔顿板（均匀三角网格，保留轨迹）   中：绝对计数直方图   下：放大相对频率 + 正态对比",
      10, 20);
  }

  function resetAll() {
    balls = [];
    ballCount = 0;
    emitAccumulator = 0;
    resetBins();
    boardCounts = [0, 0];
    pegDecisionCount = 0;
    finishedBalls = 0;
    recomputeArms();
  }

  // ===== 主循环 =====
  function loop(timestamp) {
    if (lastTime === null) lastTime = timestamp;
    const dt = timestamp - lastTime;
    lastTime = timestamp;

    const ballSpeed = baseBallSpeed * speedFactor;
    const ballsPerSec = baseBallsPerSec * speedFactor;

    emitBalls(dt, ballsPerSec);
    balls.forEach(b => b.step(dt, ballSpeed));

    const stats = computeStats();

    drawBackground();
    drawPegs();
    balls.forEach(b => b.draw(ctx));
    drawHistogram(stats);
    drawDetailInset(stats);

    const totalDecisions = boardCounts[0] + boardCounts[1];
    const ratioA = totalDecisions > 0 ? (boardCounts[0] / totalDecisions) : 0;
    const ratioB = totalDecisions > 0 ? (boardCounts[1] / totalDecisions) : 0;

    infoText.textContent =
      `策略 = ${strategy} | ` +
      `已落完球数 = ${finishedBalls} | ` +
      `撞钉决策次数 = ${totalDecisions} | ` +
      `板 A 次数 = ${boardCounts[0]} (${(ratioA*100).toFixed(1)}%) , ` +
      `板 B 次数 = ${boardCounts[1]} (${(ratioB*100).toFixed(1)}%) | ` +
      `p_A = ${pRightA.toFixed(2)} , p_B = ${pRightB.toFixed(2)} | ` +
      `θ_{n,c} 参数：c = ${cParam.toFixed(2)}, n = ${nTheta} | ` +
      `拟合 μ = ${stats.total > 0 ? stats.mean.toFixed(2) : '—'} , σ = ${stats.total > 0 ? stats.std.toFixed(2) : '—'}`;

    requestAnimationFrame(loop);
  }

  resetAll();
  requestAnimationFrame(loop);
</script>
</body>
</html>
